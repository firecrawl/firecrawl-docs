---
title: "Template de UI do Conector Web"
description: "Um guia para configurar uma interface de ingest√£o web usando o Firecrawl com React."
og:title: "Template de UI do Conector Web | Firecrawl"
og:description: "Aprenda a configurar uma interface de ingest√£o web usando o Firecrawl com React."
---

> Observa√ß√£o: este exemplo usa a [vers√£o v0 da API do Firecrawl](/pt-BR/v0/introduction). Voc√™ pode instalar a vers√£o 0.0.20 do SDK de Python ou a 0.0.36 do SDK de Node.

Este template simplifica a cria√ß√£o de uma interface de conector web para o Firecrawl usando React.
Ele inclui um componente pr√©-pronto que se integra √† API do Firecrawl, permitindo configurar rapidamente uma interface de crawling e scraping para que os usu√°rios extraiam dados para suas aplica√ß√µes de IA.
![Firecrawl UI Template](/images/firecrawl-ui.png)

Este template permite que os usu√°rios informem uma URL para crawling. Se subp√°ginas forem detectadas, ele as rastrear√° e exibir√° uma lista de URLs descobertas. Os usu√°rios podem ent√£o selecionar quais URLs ser√£o raspadas, e o conte√∫do raspado ser√° ingerido na aplica√ß√£o de IA e exibido na interface.

> **Considera√ß√£o de seguran√ßa: Este exemplo exp√µe chaves da API do Firecrawl no c√≥digo do lado do cliente. Para uso em produ√ß√£o, √© fortemente recomendado mover as intera√ß√µes com a API para uma implementa√ß√£o no lado do servidor, a fim de proteger suas chaves.**

<div id="prerequisites">
  ## Pr√©-requisitos
</div>

* Node.js (recomendado v14 ou superior)
* npm
* Certifique-se de que o [shadcn](https://github.com/shadcn-ui/ui) est√° instalado
* Certifique-se de que o [tailwindcss](https://tailwindcss.com/docs/installation) est√° instalado

<div id="getting-started">
  ## Introdu√ß√£o
</div>

1. Instale as depend√™ncias:

* Instale os [componentes shadcn](https://github.com/shadcn-ui/ui) de que voc√™ vai precisar:

```
npx shadcn-ui@latest add button card checkbox collapsible input label
```

* Instale o restante das depend√™ncias:

```
npm install clsx lucide-react tailwind-merge tailwindcss-animate class-variance-authority
```

2. Crie o arquivo `lib/utils.ts` e adicione o seguinte c√≥digo:

```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

3. Copie e cole nosso componente principal de ingest√£o. **Certifique-se de substituir `FIRECRAWL_API_KEY` pela sua chave.**

<Accordion title="Componente de Ingest√£o (ingestion.tsx)">
  ```jsx
  import { useState, ChangeEvent, FormEvent, useEffect } from "react";
  import {
    Card,
    CardHeader,
    CardTitle,
    CardContent,
    CardFooter,
  } from "@/components/ui/card";
  import { Input } from "@/components/ui/input";
  import { Button } from "@/components/ui/button";
  import { Checkbox } from "@/components/ui/checkbox";
  import { Label } from "@/components/ui/label";
  import {
    Collapsible,
    CollapsibleContent,
    CollapsibleTrigger,
  } from "@/components/ui/collapsible";
  import { ChevronDown, ChevronLeft, ChevronRight } from "lucide-react";

  //! Valores fixos (n√£o recomendado para produ√ß√£o)
  //! √â altamente recomendado mover todas as chamadas √† API do Firecrawl para o backend (ex.: rota de API do Next.js)
  const FIRECRAWL_API_URL = "https://api.firecrawl.dev"; // Substitua pela URL real da sua API, seja local ou usando o Firecrawl Cloud
  const FIRECRAWL_API_KEY = "fc-YOUR_API_KEY"; // Substitua pela sua chave de API

  interface FormData {
    url: string;
    crawlSubPages: boolean;
    limit: string;
    maxDepth: string;
    excludePaths: string;
    includePaths: string;
    extractMainContent: boolean;
  }

  interface CrawlerOptions {
    includes?: string[];
    excludes?: string[];
    maxDepth?: number;
    limit?: number;
    returnOnlyUrls: boolean;
  }

  interface PageOptions {
    onlyMainContent: boolean;
  }

  interface RequestBody {
    url: string;
    crawlerOptions?: CrawlerOptions;
    pageOptions: PageOptions;
  }

  interface ScrapeResultMetadata {
    title: string;
    description: string;
    language: string;
    sourceURL: string;
    pageStatusCode: number;
    pageError?: string;
    [key: string]: string | number | undefined;
  }

  interface ScrapeResultData {
    markdown: string;
    content: string;
    html: string;
    rawHtml: string;
    metadata: ScrapeResultMetadata;
    llm_extraction: Record<string, unknown>;
    warning?: string;
  }

  interface ScrapeResult {
    success: boolean;
    data: ScrapeResultData;
  }

  export default function FirecrawlComponent() {
    const [formData, setFormData] = useState<FormData>({
      url: "",
      crawlSubPages: false,
      limit: "",
      maxDepth: "",
      excludePaths: "",
      includePaths: "",
      extractMainContent: false,
    });
    const [loading, setLoading] = useState<boolean>(false);
    const [scrapingSelectedLoading, setScrapingSelectedLoading] =
      useState<boolean>(false);
    const [crawledUrls, setCrawledUrls] = useState<string[]>([]);
    const [selectedUrls, setSelectedUrls] = useState<string[]>([]);
    const [scrapeResults, setScrapeResults] = useState<
      Record<string, ScrapeResult>
    >({});
    const [isCollapsibleOpen, setIsCollapsibleOpen] = useState(true);
    const [crawlStatus, setCrawlStatus] = useState<{
      current: number;
      total: number | null;
    }>({ current: 0, total: null });
    const [elapsedTime, setElapsedTime] = useState<number>(0);
    const [showCrawlStatus, setShowCrawlStatus] = useState<boolean>(false);
    const [isScraping, setIsScraping] = useState<boolean>(false);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const urlsPerPage = 10;

    useEffect(() => {
      let timer: NodeJS.Timeout;
      if (loading) {
        setShowCrawlStatus(true);
        timer = setInterval(() => {
          setElapsedTime((prevTime) => prevTime + 1);
        }, 1000);
      }
      return () => {
        if (timer) clearInterval(timer);
      };
    }, [loading]);

    const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
      const { name, value, type, checked } = e.target;
      setFormData((prevData) => ({
        ...prevData,
        [name]: type === "checkbox" ? checked : value,
      }));
    };

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setLoading(true);
      setIsCollapsibleOpen(false);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: null });
      setIsScraping(!formData.crawlSubPages);
      setCrawledUrls([]);
      setSelectedUrls([]);
      setScrapeResults({});
      setScrapingSelectedLoading(false);
      setShowCrawlStatus(false);

      try {
        const endpoint = `${FIRECRAWL_API_URL}/v0/${
          formData.crawlSubPages ? "crawl" : "scrape"
        }`;

        const requestBody: RequestBody = formData.crawlSubPages
          ? {
              url: formData.url,
              crawlerOptions: {
                includes: formData.includePaths
                  ? formData.includePaths.split(",").map((p) => p.trim())
                  : undefined,
                excludes: formData.excludePaths
                  ? formData.excludePaths.split(",").map((p) => p.trim())
                  : undefined,
                maxDepth: formData.maxDepth
                  ? parseInt(formData.maxDepth)
                  : undefined,
                limit: formData.limit ? parseInt(formData.limit) : undefined,
                returnOnlyUrls: true,
              },
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }
          : {
              url: formData.url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            };

        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          throw new Error(`Erro HTTP! status: ${response.status}`);
        }

        const data = await response.json();
        if (formData.crawlSubPages) {
          const jobId = data.jobId;
          if (jobId) {
            const statusEndpoint = `${FIRECRAWL_API_URL}/v0/crawl/status/${jobId}`;
            let statusData: {
              status: string;
              data?: { url: string }[];
              current?: number;
              total?: number;
            };
            do {
              const statusResponse = await fetch(statusEndpoint, {
                headers: {
                  Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
                },
              });
              if (statusResponse.ok) {
                statusData = await statusResponse.json();

                const urls = statusData.data
                  ? statusData.data.map((urlObj) => urlObj.url)
                  : [];
                setCrawledUrls(urls);
                setSelectedUrls(urls);
                setCrawlStatus({
                  current: urls.length || 0,
                  total: urls.length || null,
                });
                if (statusData.status !== "completed") {
                  // Wait for 1 second before polling again
                  await new Promise((resolve) => setTimeout(resolve, 1000));
                  console.log("Consultando novamente...");
                  console.log(statusData);
                } else {
                  console.log("Crawl conclu√≠do com status:", statusData.status);
                  console.log(statusData);
                }
              } else {
                console.error("Falha ao buscar o status do crawl");
                break;
              }
            } while (statusData.status !== "completed");
          } else {
            console.error("Nenhum jobId recebido na solicita√ß√£o de crawl");
          }
        } else {
          setScrapeResults({ [formData.url]: data });
          setCrawlStatus({ current: 1, total: 1 });
        }
      } catch (error) {
        console.error("Erro:", error);
        setScrapeResults({
          error: {
            success: false,
            data: {
              metadata: {
                pageError: "Ocorreu um erro ao obter os dados",
                title: "",
                description: "",
                language: "",
                sourceURL: "",
                pageStatusCode: 0,
              },
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              llm_extraction: {},
            },
          },
        });
      } finally {
        setLoading(false);
      }
    };

    const handleScrapeSelected = async () => {
      setLoading(true);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: selectedUrls.length });
      setIsScraping(true);
      setScrapingSelectedLoading(true);
      const newScrapeResults: Record<string, ScrapeResult> = {};

      for (const [index, url] of selectedUrls.entries()) {
        try {
          const response = await fetch(`${FIRECRAWL_API_URL}/v0/scrape`, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              url: url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }),
          });

          if (!response.ok) {
            throw new Error(`Erro HTTP! status: ${response.status}`);
          }

          const data: ScrapeResult = await response.json();
          newScrapeResults[url] = data;
          setCrawlStatus((prev) => ({ ...prev, current: index + 1 }));
          setScrapeResults({ ...scrapeResults, ...newScrapeResults });
        } catch (error) {
          console.error(`Erro ao fazer scrape de ${url}:`, error);
          newScrapeResults[url] = {
            success: false,
            data: {
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              metadata: {
                title: "",
                description: "",
                language: "",
                sourceURL: url,
                pageStatusCode: 0,
                pageError: (error as Error).message,
              },
              llm_extraction: {},
            },
          };
        }
      }

      setLoading(false);
      setIsScraping(false);
    };

    const handlePageChange = (newPage: number) => {
      setCurrentPage(newPage);
    };

    const paginatedUrls = crawledUrls.slice(
      (currentPage - 1) * urlsPerPage,
      currentPage * urlsPerPage
    );

    return (
      <div className="max-w-2xl mx-auto p-4">
        <Card>
          <CardHeader className="flex items-start justify-between mb-0 pb-4">
            <CardTitle className="flex items-center justify-between w-full space-x-2">
              <span className="text-base">Extrair conte√∫do da web</span>
              <a
                href="https://www.firecrawl.dev"
                className="text-xs text-gray-500 font-normal px-3 py-1 bg-zinc-100 rounded-xl hover:bg-zinc-200 transition-colors"
              >
                Powered by Firecrawl üî•
              </a>
            </CardTitle>
            <div className="text-sm text-gray-500 w-11/12 items-center">
              Use este componente para dar rapidamente aos seus usu√°rios a capacidade de conectar
              seus apps de IA a dados da web com o Firecrawl. Saiba mais na{" "}
              <a
                href="https://docs.firecrawl.dev/"
                className="text-sm text-blue-500"
              >
                documenta√ß√£o do Firecrawl!
              </a>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <form onSubmit={handleSubmit}>
              <div className="flex items-center space-x-2">
                <Input
                  placeholder="https://www.firecrawl.dev/"
                  className="flex-grow"
                  name="url"
                  value={formData.url}
                  onChange={handleChange}
                />
                <Button type="submit" variant="default" disabled={loading}>
                  {loading ? (
                    <div
                      role="status"
                      className="flex items-center justify-between space-x-2"
                    >
                      <svg
                        className="animate-spin  h-4 w-4 text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                        ></circle>
                        <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                      <span className="sr-only">Carregando...</span>
                    </div>
                  ) : (
                    "Executar"
                  )}
                </Button>
              </div>
              <Collapsible
                open={isCollapsibleOpen}
                onOpenChange={setIsCollapsibleOpen}
                className="mt-2"
              >
                <CollapsibleTrigger asChild>
                  <Button variant="ghost" className="w-full justify-between pl-2">
                    Op√ß√µes avan√ßadas
                    <ChevronDown className="h-4 w-4 opacity-50" />
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="space-y-4 mt-4 px-2">
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="crawlSubPages"
                      name="crawlSubPages"
                      checked={formData.crawlSubPages}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          crawlSubPages: checked,
                        }))
                      }
                    />
                    <label htmlFor="crawlSubPages" className="text-sm">
                      Rastrear subp√°ginas
                    </label>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="limit"
                        className="block text-left w-full pb-2"
                      >
                        Limite *
                      </Label>
                      <Input
                        id="limit"
                        name="limit"
                        placeholder="10"
                        value={formData.limit}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="maxDepth"
                        className="block text-left w-full pb-2"
                      >
                        Profundidade m√°xima
                      </Label>
                      <Input
                        id="maxDepth"
                        name="maxDepth"
                        placeholder="5"
                        value={formData.maxDepth}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="excludePaths"
                        className="block text-left w-full pb-2"
                      >
                        Excluir caminhos
                      </Label>
                      <Input
                        id="excludePaths"
                        name="excludePaths"
                        placeholder="blog/, /about/"
                        value={formData.excludePaths}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="includePaths"
                        className="block text-left w-full pb-2"
                      >
                        Incluir somente caminhos
                      </Label>
                      <Input
                        id="includePaths"
                        name="includePaths"
                        placeholder="articles/"
                        value={formData.includePaths}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="extractMainContent"
                      name="extractMainContent"
                      checked={formData.extractMainContent}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          extractMainContent: checked,
                        }))
                      }
                    />
                    <label htmlFor="extractMainContent" className="text-sm">
                      Extrair apenas o conte√∫do principal (sem cabe√ßalhos, menus, rodap√©s etc.)
                    </label>
                  </div>
                </CollapsibleContent>
              </Collapsible>
            </form>
            {showCrawlStatus && (
              <div className="flex items-center justify-between mb-2 space-x-2 bg-gray-100 p-2 rounded-md">
                <div className="flex items-center space-x-2">
                  {!isScraping &&
                    crawledUrls.length > 0 &&
                    !scrapingSelectedLoading && (
                      <>
                        <Checkbox
                          id="selectAll"
                          checked={selectedUrls.length === crawledUrls.length}
                          onCheckedChange={(checked) => {
                            if (checked) {
                              setSelectedUrls([...crawledUrls]);
                            } else {
                              setSelectedUrls([]);
                            }
                          }}
                        />
                        <label
                          htmlFor="selectAll"
                          className="text-sm cursor-pointer"
                        >
                          {selectedUrls.length === crawledUrls.length
                            ? `Desmarcar tudo (${selectedUrls.length})`
                            : `Selecionar tudo (${selectedUrls.length})`}
                        </label>
                      </>
                    )}
                </div>
                <div className="text-sm text-gray-600">
                  {isScraping
                    ? `P√°ginas com scrape: ${crawlStatus.current} em ${elapsedTime}s`
                    : `P√°ginas rastreadas: ${crawlStatus.current} em ${elapsedTime}s`}
                </div>
              </div>
            )}

            {crawledUrls.length > 0 &&
              !scrapingSelectedLoading &&
              !isScraping && (
                <>
                  <ul className="pl-2">
                    {paginatedUrls.map((url, index) => (
                      <li
                        key={index}
                        className="flex items-center space-x-2 my-2 text-sm"
                      >
                        <Checkbox
                          checked={selectedUrls.includes(url)}
                          onCheckedChange={() =>
                            setSelectedUrls((prev) =>
                              prev.includes(url)
                                ? prev.filter((u) => u !== url)
                                : [...prev, url]
                            )
                          }
                        />
                        <span className="flex items-center max-w-lg">
                          {url.length > 70 ? `${url.slice(0, 70)}...` : url}
                        </span>
                      </li>
                    ))}
                  </ul>
                  <div className="flex items-center justify-between mt-4">
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage - 1)}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-5 w-5" />
                    </Button>
                    <span className="text-sm text-gray-500">
                      P√°gina {currentPage} de{" "}
                      {Math.ceil(crawledUrls.length / urlsPerPage)}
                    </span>
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage + 1)}
                      disabled={currentPage * urlsPerPage >= crawledUrls.length}
                    >
                      <ChevronRight className="h-5 w-5 " />
                    </Button>
                  </div>
                </>
              )}
          </CardContent>
          <CardFooter className="w-full flex justify-center">
            {crawledUrls.length > 0 && !scrapingSelectedLoading && (
              <Button
                variant="default"
                className="w-full"
                onClick={handleScrapeSelected}
                disabled={loading || selectedUrls.length === 0}
              >
                Fazer scrape das URLs selecionadas
              </Button>
            )}
          </CardFooter>
        </Card>

        {Object.keys(scrapeResults).length > 0 && (
          <div className="mt-4">
            <h2 className="text-base font-bold ">Resultados do scrape</h2>
            <p className="text-sm text-gray-500">
              Voc√™ pode fazer o que quiser com os resultados do scrape. Aqui vai
              uma demonstra√ß√£o b√°sica do markdown.
            </p>
            <div className="flex flex-col gap-4 mt-4 w-full">
              {Object.entries(scrapeResults).map(([url, result]) => (
                <Card key={url} className="relative p-4 w-full">
                  <CardTitle className="text-sm font-normal flex flex-col">
                    <span>{result.data.metadata.title}</span>
                    <span className="text-xs text-gray-500">
                      {url
                        .replace(/^(https?:\/\/)?(www\.)?/, "")
                        .replace(/\/$/, "")}
                    </span>
                  </CardTitle>
                  <CardContent className="relative px-0 pt-2 !text-xs w-full">
                    <div className=" overflow-y-auto h-32 bg-zinc-100 rounded-md p-2 w-full">
                      {result.success ? (
                        <>
                          <pre className="text-xs whitespace-pre-wrap">
                            {result.data.markdown.trim()}
                          </pre>
                        </>
                      ) : (
                        <>
                          <p className="text-red-500">
                            Falha ao fazer scrape desta URL
                          </p>
                          <p className="text-zinc-500 font-mono">
                            {result.toString()}
                          </p>
                        </>
                      )}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }
  ```
</Accordion>

<div id="customization">
  ## Customiza√ß√£o
</div>

Como isto n√£o √© uma biblioteca, voc√™ pode personalizar a interface como preferir. Basta editar o c√≥digo, como no shadcn.

<div id="security-considerations">
  ## Considera√ß√µes de seguran√ßa
</div>

Para uso em produ√ß√£o, considere as seguintes medidas de seguran√ßa:

* Mova as intera√ß√µes com a API para uma implementa√ß√£o no lado do servidor, a fim de proteger sua chave de API do Firecrawl.

<div id="learn-more">
  ## Saiba mais
</div>

Para obter mais informa√ß√µes sobre o Firecrawl e sua API, visite a [documenta√ß√£o do Firecrawl](https://docs.firecrawl.dev/).

<div id="contributing">
  ## Contribui√ß√£o
</div>

Contribui√ß√µes s√£o bem-vindas! Fique √† vontade para abrir um Pull Request.

<div id="license">
  ## Licen√ßa
</div>

O modelo de UI de Ingest√£o do Firecrawl √© licenciado sob a licen√ßa MIT.