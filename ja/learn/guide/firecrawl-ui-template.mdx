---
title: "Web Connector UI ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ"
description: "Firecrawl ã‚’ React ã§ä½¿ç”¨ã—ã¦ã€Web å–ã‚Šè¾¼ã¿ç”¨ã® UI ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹ãŸã‚ã®ã‚¬ã‚¤ãƒ‰ã€‚"
og:title: "Web Connector UI ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ | Firecrawl"
og:description: "Firecrawl ã‚’ React ã§ä½¿ç”¨ã—ã¦ã€Web å–ã‚Šè¾¼ã¿ç”¨ã® UI ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹æ–¹æ³•ã‚’å­¦ã³ã¾ã™ã€‚"
---

> æ³¨æ„: ã“ã®ä¾‹ã¯ [Firecrawl API ã® v0 ãƒãƒ¼ã‚¸ãƒ§ãƒ³](/ja/v0/introduction) ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚Python SDK ã¯ 0.0.20ã€Node SDK ã¯ 0.0.36 ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ãã¾ã™ã€‚

ã“ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¯ã€React ã‚’ç”¨ã„ã¦ Firecrawl å‘ã‘ã® Web ã‚³ãƒã‚¯ã‚¿ UI ã‚’æ‰‹æ—©ãä½œæˆã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
Firecrawl API ã¨é€£æºã™ã‚‹ãƒ—ãƒªãƒ“ãƒ«ãƒˆã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒå«ã¾ã‚Œã¦ãŠã‚Šã€Web ã®ã‚¯ãƒ­ãƒ¼ãƒ«ã¨ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ç”¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ç´ æ—©ãæ§‹ç¯‰ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ AI ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å‘ã‘ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
![Firecrawl UI Template](/images/firecrawl-ui.png)

ã“ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¯ãƒ­ãƒ¼ãƒ«å¯¾è±¡ã® URL ã‚’å…¥åŠ›ã§ãã¾ã™ã€‚ã‚µãƒ–ãƒšãƒ¼ã‚¸ãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã¯ãã‚Œã‚‰ã‚‚ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã€è¦‹ã¤ã‹ã£ãŸ URL ã®ä¸€è¦§ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ—ã™ã‚‹ URL ã‚’é¸æŠã§ãã€ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ—ã—ãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯ AI ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«å–ã‚Šè¾¼ã¾ã‚Œã€UI ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

> **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®æ³¨æ„: ã“ã®ä¾‹ã§ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã‚³ãƒ¼ãƒ‰ã§ Firecrawl ã® API ã‚­ãƒ¼ãŒéœ²å‡ºã—ã¾ã™ã€‚æœ¬ç•ªç’°å¢ƒã§ã¯ã€API ã‚­ãƒ¼ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã« API é€£æºã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰å®Ÿè£…ã¸ç§»ã™ã“ã¨ã‚’å¼·ãæ¨å¥¨ã—ã¾ã™ã€‚**

<div id="prerequisites">
  ## å‰ææ¡ä»¶
</div>

* Node.jsï¼ˆv14 ä»¥ä¸Šæ¨å¥¨ï¼‰
* npm
* [shadcn](https://github.com/shadcn-ui/ui) ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨
* [tailwindcss](https://tailwindcss.com/docs/installation) ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨

<div id="getting-started">
  ## ã¯ã˜ã‚ã«
</div>

1. ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«:

* å¿…è¦ãª [shadcn components](https://github.com/shadcn-ui/ui) ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«:

```
npx shadcn-ui@latest add button card checkbox collapsible input label
```

* æ®‹ã‚Šã®ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ï¼š

```
npm install clsx lucide-react tailwind-merge tailwindcss-animate class-variance-authority
```

2. `lib/utils.ts` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„:

```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

3. ãƒ¡ã‚¤ãƒ³ã®ã‚¤ãƒ³ã‚¸ã‚§ã‚¹ãƒˆç”¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¾ã™ã€‚**å¿…ãš `FIRECRAWL_API_KEY` ã‚’ã”è‡ªèº«ã®ã‚­ãƒ¼ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚**

<Accordion title="å–ã‚Šè¾¼ã¿ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆingestion.tsxï¼‰">
  ```jsx
  import { useState, ChangeEvent, FormEvent, useEffect } from "react";
  import {
    Card,
    CardHeader,
    CardTitle,
    CardContent,
    CardFooter,
  } from "@/components/ui/card";
  import { Input } from "@/components/ui/input";
  import { Button } from "@/components/ui/button";
  import { Checkbox } from "@/components/ui/checkbox";
  import { Label } from "@/components/ui/label";
  import {
    Collapsible,
    CollapsibleContent,
    CollapsibleTrigger,
  } from "@/components/ui/collapsible";
  import { ChevronDown, ChevronLeft, ChevronRight } from "lucide-react";

  //! ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå€¤ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯éæ¨å¥¨ï¼‰
  //! ã™ã¹ã¦ã® Firecrawl API å‘¼ã³å‡ºã—ã¯ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆä¾‹ï¼šNext.js ã® API ãƒ«ãƒ¼ãƒˆï¼‰ã¸ç§»ã™ã“ã¨ã‚’å¼·ãæ¨å¥¨ã—ã¾ã™
  const FIRECRAWL_API_URL = "https://api.firecrawl.dev"; // Replace with your actual API URL whether it is local or using Firecrawl Cloud
  const FIRECRAWL_API_KEY = "fc-YOUR_API_KEY"; // Replace with your actual API key

  interface FormData {
    url: string;
    crawlSubPages: boolean;
    limit: string;
    maxDepth: string;
    excludePaths: string;
    includePaths: string;
    extractMainContent: boolean;
  }

  interface CrawlerOptions {
    includes?: string[];
    excludes?: string[];
    maxDepth?: number;
    limit?: number;
    returnOnlyUrls: boolean;
  }

  interface PageOptions {
    onlyMainContent: boolean;
  }

  interface RequestBody {
    url: string;
    crawlerOptions?: CrawlerOptions;
    pageOptions: PageOptions;
  }

  interface ScrapeResultMetadata {
    title: string;
    description: string;
    language: string;
    sourceURL: string;
    pageStatusCode: number;
    pageError?: string;
    [key: string]: string | number | undefined;
  }

  interface ScrapeResultData {
    markdown: string;
    content: string;
    html: string;
    rawHtml: string;
    metadata: ScrapeResultMetadata;
    llm_extraction: Record<string, unknown>;
    warning?: string;
  }

  interface ScrapeResult {
    success: boolean;
    data: ScrapeResultData;
  }

  export default function FirecrawlComponent() {
    const [formData, setFormData] = useState<FormData>({
      url: "",
      crawlSubPages: false,
      limit: "",
      maxDepth: "",
      excludePaths: "",
      includePaths: "",
      extractMainContent: false,
    });
    const [loading, setLoading] = useState<boolean>(false);
    const [scrapingSelectedLoading, setScrapingSelectedLoading] =
      useState<boolean>(false);
    const [crawledUrls, setCrawledUrls] = useState<string[]>([]);
    const [selectedUrls, setSelectedUrls] = useState<string[]>([]);
    const [scrapeResults, setScrapeResults] = useState<
      Record<string, ScrapeResult>
    >({});
    const [isCollapsibleOpen, setIsCollapsibleOpen] = useState(true);
    const [crawlStatus, setCrawlStatus] = useState<{
      current: number;
      total: number | null;
    }>({ current: 0, total: null });
    const [elapsedTime, setElapsedTime] = useState<number>(0);
    const [showCrawlStatus, setShowCrawlStatus] = useState<boolean>(false);
    const [isScraping, setIsScraping] = useState<boolean>(false);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const urlsPerPage = 10;

    useEffect(() => {
      let timer: NodeJS.Timeout;
      if (loading) {
        setShowCrawlStatus(true);
        timer = setInterval(() => {
          setElapsedTime((prevTime) => prevTime + 1);
        }, 1000);
      }
      return () => {
        if (timer) clearInterval(timer);
      };
    }, [loading]);

    const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
      const { name, value, type, checked } = e.target;
      setFormData((prevData) => ({
        ...prevData,
        [name]: type === "checkbox" ? checked : value,
      }));
    };

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setLoading(true);
      setIsCollapsibleOpen(false);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: null });
      setIsScraping(!formData.crawlSubPages);
      setCrawledUrls([]);
      setSelectedUrls([]);
      setScrapeResults({});
      setScrapingSelectedLoading(false);
      setShowCrawlStatus(false);

      try {
        const endpoint = `${FIRECRAWL_API_URL}/v0/${
          formData.crawlSubPages ? "crawl" : "scrape"
        }`;

        const requestBody: RequestBody = formData.crawlSubPages
          ? {
              url: formData.url,
              crawlerOptions: {
                includes: formData.includePaths
                  ? formData.includePaths.split(",").map((p) => p.trim())
                  : undefined,
                excludes: formData.excludePaths
                  ? formData.excludePaths.split(",").map((p) => p.trim())
                  : undefined,
                maxDepth: formData.maxDepth
                  ? parseInt(formData.maxDepth)
                  : undefined,
                limit: formData.limit ? parseInt(formData.limit) : undefined,
                returnOnlyUrls: true,
              },
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }
          : {
              url: formData.url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            };

        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (formData.crawlSubPages) {
          const jobId = data.jobId;
          if (jobId) {
            const statusEndpoint = `${FIRECRAWL_API_URL}/v0/crawl/status/${jobId}`;
            let statusData: {
              status: string;
              data?: { url: string }[];
              current?: number;
              total?: number;
            };
            do {
              const statusResponse = await fetch(statusEndpoint, {
                headers: {
                  Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
                },
              });
              if (statusResponse.ok) {
                statusData = await statusResponse.json();

                const urls = statusData.data
                  ? statusData.data.map((urlObj) => urlObj.url)
                  : [];
                setCrawledUrls(urls);
                setSelectedUrls(urls);
                setCrawlStatus({
                  current: urls.length || 0,
                  total: urls.length || null,
                });
                if (statusData.status !== "completed") {
                  // Wait for 1 second before polling again
                  await new Promise((resolve) => setTimeout(resolve, 1000));
                  console.log("å†åº¦ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¾ã™â€¦");
                  console.log(statusData);
                } else {
                  console.log("ã‚¯ãƒ­ãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:", statusData.status);
                  console.log(statusData);
                }
              } else {
                console.error("ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ");
                break;
              }
            } while (statusData.status !== "completed");
          } else {
            console.error("ã‚¯ãƒ­ãƒ¼ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ jobId ã‚’å—ã‘å–ã‚Œã¾ã›ã‚“ã§ã—ãŸ");
          }
        } else {
          setScrapeResults({ [formData.url]: data });
          setCrawlStatus({ current: 1, total: 1 });
        }
      } catch (error) {
        console.error("ã‚¨ãƒ©ãƒ¼:", error);
        setScrapeResults({
          error: {
            success: false,
            data: {
              metadata: {
                pageError: "ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ",
                title: "",
                description: "",
                language: "",
                sourceURL: "",
                pageStatusCode: 0,
              },
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              llm_extraction: {},
            },
          },
        });
      } finally {
        setLoading(false);
      }
    };

    const handleScrapeSelected = async () => {
      setLoading(true);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: selectedUrls.length });
      setIsScraping(true);
      setScrapingSelectedLoading(true);
      const newScrapeResults: Record<string, ScrapeResult> = {};

      for (const [index, url] of selectedUrls.entries()) {
        try {
          const response = await fetch(`${FIRECRAWL_API_URL}/v0/scrape`, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              url: url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data: ScrapeResult = await response.json();
          newScrapeResults[url] = data;
          setCrawlStatus((prev) => ({ ...prev, current: index + 1 }));
          setScrapeResults({ ...scrapeResults, ...newScrapeResults });
        } catch (error) {
          console.error(`URL ã®ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${url}:`, error);
          newScrapeResults[url] = {
            success: false,
            data: {
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              metadata: {
                title: "",
                description: "",
                language: "",
                sourceURL: url,
                pageStatusCode: 0,
                pageError: (error as Error).message,
              },
              llm_extraction: {},
            },
          };
        }
      }

      setLoading(false);
      setIsScraping(false);
    };

    const handlePageChange = (newPage: number) => {
      setCurrentPage(newPage);
    };

    const paginatedUrls = crawledUrls.slice(
      (currentPage - 1) * urlsPerPage,
      currentPage * urlsPerPage
    );

    return (
      <div className="max-w-2xl mx-auto p-4">
        <Card>
          <CardHeader className="flex items-start justify-between mb-0 pb-4">
            <CardTitle className="flex items-center justify-between w-full space-x-2">
              <span className="text-base">Web ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æŠ½å‡º</span>
              <a
                href="https://www.firecrawl.dev"
                className="text-xs text-gray-500 font-normal px-3 py-1 bg-zinc-100 rounded-xl hover:bg-zinc-200 transition-colors"
              >
                Powered by Firecrawl ğŸ”¥
              </a>
            </CardTitle>
            <div className="text-sm text-gray-500 w-11/12 items-center">
              Use this component to quickly give your users the ability to connect
              their AI apps to web data with Firecrawl. Learn more on the{" "}
              <a
                href="https://docs.firecrawl.dev/"
                className="text-sm text-blue-500"
              >
                Firecrawl docs!
              </a>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <form onSubmit={handleSubmit}>
              <div className="flex items-center space-x-2">
                <Input
                  placeholder="https://www.firecrawl.dev/"
                  className="flex-grow"
                  name="url"
                  value={formData.url}
                  onChange={handleChange}
                />
                <Button type="submit" variant="default" disabled={loading}>
                  {loading ? (
                    <div
                      role="status"
                      className="flex items-center justify-between space-x-2"
                    >
                      <svg
                        className="animate-spin  h-4 w-4 text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                        ></circle>
                        <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                      <span className="sr-only">èª­ã¿è¾¼ã¿ä¸­â€¦</span>
                    </div>
                  ) : (
                    "å®Ÿè¡Œ"
                  )}
                </Button>
              </div>
              <Collapsible
                open={isCollapsibleOpen}
                onOpenChange={setIsCollapsibleOpen}
                className="mt-2"
              >
                <CollapsibleTrigger asChild>
                  <Button variant="ghost" className="w-full justify-between pl-2">
                    è©³ç´°ã‚ªãƒ—ã‚·ãƒ§ãƒ³
                    <ChevronDown className="h-4 w-4 opacity-50" />
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="space-y-4 mt-4 px-2">
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="crawlSubPages"
                      name="crawlSubPages"
                      checked={formData.crawlSubPages}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          crawlSubPages: checked,
                        }))
                      }
                    />
                    <label htmlFor="crawlSubPages" className="text-sm">
                      ã‚µãƒ–ãƒšãƒ¼ã‚¸ã‚’ã‚¯ãƒ­ãƒ¼ãƒ«
                    </label>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="limit"
                        className="block text-left w-full pb-2"
                      >
                        ä¸Šé™ *
                      </Label>
                      <Input
                        id="limit"
                        name="limit"
                        placeholder="10"
                        value={formData.limit}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="maxDepth"
                        className="block text-left w-full pb-2"
                      >
                        æœ€å¤§æ·±åº¦
                      </Label>
                      <Input
                        id="maxDepth"
                        name="maxDepth"
                        placeholder="5"
                        value={formData.maxDepth}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="excludePaths"
                        className="block text-left w-full pb-2"
                      >
                        é™¤å¤–ãƒ‘ã‚¹
                      </Label>
                      <Input
                        id="excludePaths"
                        name="excludePaths"
                        placeholder="blog/, /about/"
                        value={formData.excludePaths}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="includePaths"
                        className="block text-left w-full pb-2"
                      >
                        å¯¾è±¡ãƒ‘ã‚¹ã®ã¿
                      </Label>
                      <Input
                        id="includePaths"
                        name="includePaths"
                        placeholder="articles/"
                        value={formData.includePaths}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="extractMainContent"
                      name="extractMainContent"
                      checked={formData.extractMainContent}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          extractMainContent: checked,
                        }))
                      }
                    />
                    <label htmlFor="extractMainContent" className="text-sm">
                      ä¸»è¦ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã¿æŠ½å‡ºï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã€ãƒŠãƒ“ã€ãƒ•ãƒƒã‚¿ãƒ¼ç­‰ã‚’é™¤å¤–ï¼‰
                    </label>
                  </div>
                </CollapsibleContent>
              </Collapsible>
            </form>
            {showCrawlStatus && (
              <div className="flex items-center justify-between mb-2 space-x-2 bg-gray-100 p-2 rounded-md">
                <div className="flex items-center space-x-2">
                  {!isScraping &&
                    crawledUrls.length > 0 &&
                    !scrapingSelectedLoading && (
                      <>
                        <Checkbox
                          id="selectAll"
                          checked={selectedUrls.length === crawledUrls.length}
                          onCheckedChange={(checked) => {
                            if (checked) {
                              setSelectedUrls([...crawledUrls]);
                            } else {
                              setSelectedUrls([]);
                            }
                          }}
                        />
                        <label
                          htmlFor="selectAll"
                          className="text-sm cursor-pointer"
                        >
                          {selectedUrls.length === crawledUrls.length
                            ? `ã™ã¹ã¦é¸æŠè§£é™¤ï¼ˆ${selectedUrls.length}ï¼‰`
                            : `ã™ã¹ã¦é¸æŠï¼ˆ${selectedUrls.length}ï¼‰`}
                        </label>
                      </>
                    )}
                </div>
                <div className="text-sm text-gray-600">
                  {isScraping
                    ? `ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°æ¸ˆã¿ ${crawlStatus.current} ãƒšãƒ¼ã‚¸ï¼ˆ${elapsedTime}ç§’ï¼‰`
                    : `ã‚¯ãƒ­ãƒ¼ãƒ«æ¸ˆã¿ ${crawlStatus.current} ãƒšãƒ¼ã‚¸ï¼ˆ${elapsedTime}ç§’ï¼‰`
                </div>
              </div>
            )}

            {crawledUrls.length > 0 &&
              !scrapingSelectedLoading &&
              !isScraping && (
                <>
                  <ul className="pl-2">
                    {paginatedUrls.map((url, index) => (
                      <li
                        key={index}
                        className="flex items-center space-x-2 my-2 text-sm"
                      >
                        <Checkbox
                          checked={selectedUrls.includes(url)}
                          onCheckedChange={() =>
                            setSelectedUrls((prev) =>
                              prev.includes(url)
                                ? prev.filter((u) => u !== url)
                                : [...prev, url]
                            )
                          }
                        />
                        <span className="flex items-center max-w-lg">
                          {url.length > 70 ? `${url.slice(0, 70)}...` : url}
                        </span>
                      </li>
                    ))}
                  </ul>
                  <div className="flex items-center justify-between mt-4">
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage - 1)}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-5 w-5" />
                    </Button>
                    <span className="text-sm text-gray-500">
                      ãƒšãƒ¼ã‚¸ {currentPage} /{" "}
                      {Math.ceil(crawledUrls.length / urlsPerPage)}
                    </span>
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage + 1)}
                      disabled={currentPage * urlsPerPage >= crawledUrls.length}
                    >
                      <ChevronRight className="h-5 w-5 " />
                    </Button>
                  </div>
                </>
              )}
          </CardContent>
          <CardFooter className="w-full flex justify-center">
            {crawledUrls.length > 0 && !scrapingSelectedLoading && (
              <Button
                variant="default"
                className="w-full"
                onClick={handleScrapeSelected}
                disabled={loading || selectedUrls.length === 0}
              >
                é¸æŠã—ãŸ URL ã‚’ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°
              </Button>
            )}
          </CardFooter>
        </Card>

        {Object.keys(scrapeResults).length > 0 && (
          <div className="mt-4">
            <h2 className="text-base font-bold ">ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°çµæœ</h2>
            <p className="text-sm text-gray-500">
              ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°çµæœã¯è‡ªç”±ã«æ´»ç”¨ã§ãã¾ã™ã€‚ä»¥ä¸‹ã¯ Markdown ã®åŸºæœ¬çš„ãªè¡¨ç¤ºä¾‹ã§ã™ã€‚
              basic showcase of the markdown.
            </p>
            <div className="flex flex-col gap-4 mt-4 w-full">
              {Object.entries(scrapeResults).map(([url, result]) => (
                <Card key={url} className="relative p-4 w-full">
                  <CardTitle className="text-sm font-normal flex flex-col">
                    <span>{result.data.metadata.title}</span>
                    <span className="text-xs text-gray-500">
                      {url
                        .replace(/^(https?:\/\/)?(www\.)?/, "")
                        .replace(/\/$/, "")}
                    </span>
                  </CardTitle>
                  <CardContent className="relative px-0 pt-2 !text-xs w-full">
                    <div className=" overflow-y-auto h-32 bg-zinc-100 rounded-md p-2 w-full">
                      {result.success ? (
                        <>
                          <pre className="text-xs whitespace-pre-wrap">
                            {result.data.markdown.trim()}
                          </pre>
                        </>
                      ) : (
                        <>
                          <p className="text-red-500">
                            ã“ã® URL ã®ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã«å¤±æ•—ã—ã¾ã—ãŸ
                          </p>
                          <p className="text-zinc-500 font-mono">
                            {result.toString()}
                          </p>
                        </>
                      )}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }
  ```
</Accordion>

<div id="customization">
  ## ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
</div>

ã“ã‚Œã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ãªã„ãŸã‚ã€UIã¯è‡ªç”±ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚shadcn ã¨åŒæ§˜ã«ã€ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã™ã‚‹ã ã‘ã§OKã§ã™ã€‚

<div id="security-considerations">
  ## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«é–¢ã™ã‚‹è€ƒæ…®äº‹é …
</div>

æœ¬ç•ªç’°å¢ƒã§ã¯ã€æ¬¡ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚

* Firecrawl ã® API ã‚­ãƒ¼ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã€API ã¨ã®ã‚„ã‚Šå–ã‚Šã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚

<div id="learn-more">
  ## ã•ã‚‰ã«è©³ã—ã
</div>

Firecrawl ã¨ãã® API ã«ã¤ã„ã¦ã®è©³ç´°ã¯ã€[Firecrawl ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.firecrawl.dev/)ã‚’ã”è¦§ãã ã•ã„ã€‚

<div id="contributing">
  ## ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆ
</div>

è²¢çŒ®ã¯å¤§æ­“è¿ã§ã™ï¼ãœã²ãŠæ°—è»½ã« Pull Request ã‚’ãŠé€ã‚Šãã ã•ã„ã€‚

<div id="license">
  ## ãƒ©ã‚¤ã‚»ãƒ³ã‚¹
</div>

Firecrawl Ingestion UI Template ã¯ MIT ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚‚ã¨ã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚