---
title: '爬取'
description: 'Firecrawl 可递归遍历某个 URL 的子域并收集内容'
og:title: "爬取 | Firecrawl"
og:description: "Firecrawl 可递归遍历某个 URL 的子域并收集内容"
icon: "spider"
---

import InstallationPython from "/snippets/zh/v2/installation/python.mdx";
import InstallationNode from "/snippets/zh/v2/installation/js.mdx";
import CrawlPython from "/snippets/zh/v2/crawl/base/python.mdx";
import CrawlNode from "/snippets/zh/v2/crawl/base/js.mdx";
import CrawlCURL from "/snippets/zh/v2/crawl/base/curl.mdx";
import CheckCrawlJobPython from "/snippets/zh/v2/crawl-status/short/python.mdx";
import CheckCrawlJobNode from "/snippets/zh/v2/crawl-status/short/js.mdx";
import CheckCrawlJobCURL from "/snippets/zh/v2/crawl-status/short/curl.mdx";
import CheckCrawlJobOutputScraping from "/snippets/zh/v2/crawl-status/base/output-scraping.mdx";
import CheckCrawlJobOutputCompleted from "/snippets/zh/v2/crawl-status/base/output-completed.mdx";
import CrawlWebSocketPython from "/snippets/zh/v2/crawl-websocket/base/python.mdx";
import CrawlWebSocketNode from "/snippets/zh/v2/crawl-websocket/base/js.mdx";
import CrawlWebhookCURL from "/snippets/zh/v2/crawl-webhook/base/curl.mdx";
import PythonCrawlExample from "/snippets/zh/v2/crawl/sdk-example/python.mdx";
import NodeCrawlExample from "/snippets/zh/v2/crawl/sdk-example/js.mdx";
import PythonCrawlExampleResponse from "/snippets/zh/v2/crawl/sdk-example/python-response.mdx";
import NodeCrawlExampleResponse from "/snippets/zh/v2/crawl/sdk-example/js-response.mdx";
import StartCrawlPython from "/snippets/v2/start-crawl/base/python.mdx";
import StartCrawlNode from "/snippets/v2/start-crawl/base/js.mdx";
import StartCrawlCURL from "/snippets/v2/start-crawl/base/curl.mdx";
import StartCrawlOutput from "/snippets/v2/start-crawl/base/output.mdx";

Firecrawl 高效爬取网站，在绕过风控的同时提取全面数据。流程如下：

1. **URL 分析：** 扫描站点地图并爬取网站以识别链接
2. **遍历：** 递归跟随链接，发现所有子页面
3. **抓取：** 从各页面提取内容，处理 JS 与速率限制
4. **输出：** 将数据转换为干净的 markdown 或结构化格式

这可确保从任意起始 URL 完整采集数据。

<div id="crawling">
  ## 爬虫
</div>

<div id="crawl-endpoint">
  ### /crawl 端点
</div>

用于爬取某个 URL 及其所有可访问的子页面。此操作会提交一个爬取作业，并返回作业 ID 以便检查爬取状态。

<Warning>默认情况下，如果页面中的子链接并非你提供的 URL 的子路径，/crawl 会忽略这些链接。因此，当你爬取 website.com/blogs/ 时，website.com/other-parent/blog-1 不会被返回。若需要包含 website.com/other-parent/blog-1，请使用 `crawlEntireDomain` 参数。若要在爬取 website.com 时同时爬取 blog.website.com 等子域名，请使用 `allowSubdomains` 参数。</Warning>

<div id="installation">
  ### 安装
</div>

<CodeGroup>
  <InstallationPython />

  <InstallationNode />
</CodeGroup>

<div id="usage">
  ### 使用方法
</div>

<CodeGroup>
  <CrawlPython />

  <CrawlNode />

  <CrawlCURL />
</CodeGroup>

<div id="scrape-options-in-crawl">
  ### 在 crawl 中的 Scrape 选项
</div>

/scrape 端点的所有选项都可通过 `scrapeOptions`（JS）/`scrape_options`（Python）在 /crawl 中使用。这些选项会应用于爬虫抓取的每个页面：formats、proxy、缓存、actions、location、tags 等。完整列表见 [Scrape API 参考](https://docs.firecrawl.dev/api-reference/endpoint/scrape)。

<CodeGroup>
  ```js Node
  import Firecrawl from '@mendable/firecrawl-js';

  const firecrawl = new Firecrawl({ apiKey: 'fc-YOUR_API_KEY' });

  // 使用 scrape 选项进行 crawl
  const crawlResponse = await firecrawl.crawl('https://example.com', {
    limit: 100,
    scrapeOptions: {
      formats: [
        'markdown',
        { type: 'json', schema: { type: 'object', properties: { title: { type: 'string' } } } }
      ],
      proxy: 'auto',
      maxAge: 600000,
      onlyMainContent: true
    }
  });
  ```

  ```python Python
  from firecrawl import Firecrawl

  firecrawl = Firecrawl(api_key='fc-YOUR_API_KEY')

  # 使用 scrape 选项进行 crawl
  response = firecrawl.crawl('https://example.com',
      limit=100,
      scrape_options={
          'formats': [
              'markdown',
              { 'type': 'json', 'schema': { 'type': 'object', 'properties': { 'title': { 'type': 'string' } } } }
          ],
          'proxy': 'auto',
          'maxAge': 600000,
          'onlyMainContent': True
      }
  )
  ```
</CodeGroup>

<div id="api-response">
  ### API 响应
</div>

如果你使用 cURL 或 starter 方法，将返回一个用于检查爬取状态的 `ID`。

<Note>如果你使用 SDK，请参阅下方的方法以了解 waiter 与 starter 的行为差异。</Note>

<StartCrawlOutput />

<div id="check-crawl-job">
  ### 检查爬取任务
</div>

用于查看爬取任务的状态并获取其结果。

<Note>此端点仅适用于正在进行或刚刚完成的爬取任务。</Note>

<CodeGroup>
  <CheckCrawlJobPython />

  <CheckCrawlJobNode />

  <CheckCrawlJobCURL />
</CodeGroup>

<div id="response-handling">
  #### 响应处理
</div>

响应内容会根据抓取任务的状态而有所不同。

对于未完成的抓取，或当响应大小超过 10MB 时，会返回一个 `next` URL 参数。你需要请求该 URL 以获取后续的每 10MB 数据。如果没有 `next` 参数，表示抓取数据已全部返回。

skip 参数用于设置每个结果分片的最大返回数量。

<Info>
  skip 和 next 参数仅在直接调用 API 时适用。若使用 SDK，我们会代为处理，并一次性返回全部结果。
</Info>

<CodeGroup>
  <CheckCrawlJobOutputScraping />

  <CheckCrawlJobOutputCompleted />
</CodeGroup>

<div id="sdk-methods">
  ### SDK 方法
</div>

使用 SDK 有两种方式：

1. **抓取并等待**（`crawl`）：
   * 等待爬取完成并返回完整响应
   * 自动处理分页
   * 适用于大多数场景，推荐使用

<CodeGroup>
  <PythonCrawlExample />

  <NodeCrawlExample />
</CodeGroup>

响应包括爬取状态及所有抓取到的数据：

<CodeGroup>
  <PythonCrawlExampleResponse />

  <NodeCrawlExampleResponse />
</CodeGroup>

2. **启动后轮询状态**（`startCrawl`/`start_crawl`）：
   * 立即返回一个爬取 ID
   * 支持手动检查进度/状态
   * 适合长时间运行的爬取或自定义轮询逻辑

<CodeGroup>
  <StartCrawlPython />

  <StartCrawlNode />

  <StartCrawlCURL />
</CodeGroup>

<div id="crawl-websocket">
  ## 爬取 WebSocket
</div>

Firecrawl 基于 WebSocket 的方法 `Crawl URL and Watch` 支持实时数据提取与监控。以 URL 启动爬取，并可通过页面数量上限、允许的域名、输出 formats 等选项进行自定义，适用于即时数据处理需求。

<CodeGroup>
  <CrawlWebSocketPython />

  <CrawlWebSocketNode />
</CodeGroup>

<div id="crawl-webhook">
  ## 爬取 Webhook
</div>

你可以配置 webhook，在爬取过程中实时接收通知。这样即可在页面被抓取后立刻处理，无需等待整个爬取任务完成。

<CrawlWebhookCURL />

有关完整的 Webhook 文档（包括事件类型、载荷结构和实现示例），请参阅[Webhooks 文档](/zh/features/webhooks)。

<div id="quick-reference">
  ### 快速参考
</div>

**事件类型：**

* `crawl.started` - 爬取开始时
* `crawl.page` - 每个成功抓取的页面
* `crawl.completed` - 爬取结束时
* `crawl.failed` - 爬取出错时

**基础载荷：**

```json
{
  "success": true,
  "type": "crawl.page",
  "id": "crawl-job-id",
  "data": [...], // “page” 事件对应的页面数据
  "metadata": {}, // 你自定义的元数据
  "error": null
}
```

<Note>
  有关 webhook 的详细配置、安全最佳实践及故障排查，请参阅 [Webhooks 文档](/zh/features/webhooks)。
</Note>
