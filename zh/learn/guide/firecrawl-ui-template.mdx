---
title: "Web Connector UI Template"
description: "ä½¿ç”¨ React ä¸ Firecrawl æ­å»ºç½‘é¡µæ•°æ®æ¥å…¥ UI çš„æŒ‡å—ã€‚"
og:title: "Web Connector UI Template | Firecrawl"
og:description: "äº†è§£å¦‚ä½•ä½¿ç”¨ React ä¸ Firecrawl æ­å»ºç”¨äºç½‘é¡µæ•°æ®æ¥å…¥çš„ UIã€‚"
---

> æ³¨æ„ï¼šæ­¤ç¤ºä¾‹ä½¿ç”¨çš„æ˜¯ [Firecrawl API çš„ v0 ç‰ˆæœ¬](/zh/v0/introduction)ã€‚ä½ å¯ä»¥ä¸º Python SDK å®‰è£… 0.0.20 ç‰ˆæœ¬ï¼Œæˆ–ä¸º Node SDK å®‰è£… 0.0.36 ç‰ˆæœ¬ã€‚

æ­¤æ¨¡æ¿ç®€åŒ–äº†ä½¿ç”¨ React ä¸º Firecrawl æ„å»ºç½‘é¡µè¿æ¥å™¨ UI çš„è¿‡ç¨‹ã€‚
å®ƒåŒ…å«ä¸€ä¸ªé¢„æ„å»ºç»„ä»¶ï¼Œå¯ä¸ Firecrawl API äº¤äº’ï¼Œå¸®åŠ©ä½ å¿«é€Ÿæ­å»ºç½‘é¡µçˆ¬å–ä¸æŠ“å–ç•Œé¢ï¼Œä¾¿äºç”¨æˆ·ä¸ºå…¶ AI åº”ç”¨æå–æ•°æ®ã€‚
![Firecrawl UI Template](/images/firecrawl-ui.png)

è¯¥æ¨¡æ¿å…è®¸ç”¨æˆ·è¾“å…¥å¾…çˆ¬å–çš„ URLã€‚è‹¥æ£€æµ‹åˆ°å­é¡µé¢ï¼Œæ¨¡æ¿ä¼šç»§ç»­çˆ¬å–å¹¶æ˜¾ç¤ºå‘ç°çš„ URL åˆ—è¡¨ã€‚éšåï¼Œç”¨æˆ·å¯é€‰æ‹©éœ€è¦æŠ“å–çš„ URLï¼ŒæŠ“å–çš„å†…å®¹å°†è¢«æ¥å…¥å…¶ AI åº”ç”¨å¹¶åœ¨ UI ä¸­æ˜¾ç¤ºã€‚

> **å®‰å…¨æç¤ºï¼šæ­¤ç¤ºä¾‹ä¼šåœ¨å®¢æˆ·ç«¯ä»£ç ä¸­æš´éœ² Firecrawl API å¯†é’¥ã€‚ç”¨äºç”Ÿäº§ç¯å¢ƒæ—¶ï¼Œå¼ºçƒˆå»ºè®®å°† API è°ƒç”¨è¿ç§»è‡³æœåŠ¡ç«¯ä»¥ä¿æŠ¤ä½ çš„ API å¯†é’¥ã€‚**

<div id="prerequisites">
  ## å‰ç½®æ¡ä»¶
</div>

* Node.jsï¼ˆå»ºè®® v14 æˆ–æ›´é«˜ï¼‰
* npm
* ç¡®ä¿å·²å®‰è£… [shadcn](https://github.com/shadcn-ui/ui)
* ç¡®ä¿å·²å®‰è£… [Tailwind CSS](https://tailwindcss.com/docs/installation)

<div id="getting-started">
  ## å…¥é—¨
</div>

1. å®‰è£…ä¾èµ–ï¼š

* å®‰è£…ä½ éœ€è¦çš„ [shadcn ç»„ä»¶](https://github.com/shadcn-ui/ui)ï¼š

```
npx shadcn-ui@latest add button card checkbox collapsible input label
```

* å®‰è£…å‰©ä½™ä¾èµ–ï¼š

```
npm install clsx lucide-react tailwind-merge tailwindcss-animate class-variance-authority
```

2. æ–°å»ºä¸€ä¸ª `lib/utils.ts` æ–‡ä»¶ï¼Œå¹¶åŠ å…¥ä»¥ä¸‹ä»£ç ï¼š

```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

3. å¤åˆ¶å¹¶ç²˜è´´æˆ‘ä»¬çš„ä¸»æ‘„å–ç»„ä»¶ã€‚**è¯·åŠ¡å¿…å°† `FIRECRAWL_API_KEY` æ›¿æ¢ä¸ºä½ çš„å¯†é’¥ã€‚**

<Accordion title="æ‘„å–ç»„ä»¶ï¼ˆingestion.tsxï¼‰">
  ```jsx
  import { useState, ChangeEvent, FormEvent, useEffect } from "react";
  import {
    Card,
    CardHeader,
    CardTitle,
    CardContent,
    CardFooter,
  } from "@/components/ui/card";
  import { Input } from "@/components/ui/input";
  import { Button } from "@/components/ui/button";
  import { Checkbox } from "@/components/ui/checkbox";
  import { Label } from "@/components/ui/label";
  import {
    Collapsible,
    CollapsibleContent,
    CollapsibleTrigger,
  } from "@/components/ui/collapsible";
  import { ChevronDown, ChevronLeft, ChevronRight } from "lucide-react";

  //! ç¡¬ç¼–ç çš„å€¼ï¼ˆä¸å»ºè®®ç”¨äºç”Ÿäº§ç¯å¢ƒï¼‰
  //! å¼ºçƒˆå»ºè®®å°†æ‰€æœ‰ Firecrawl API è°ƒç”¨ç§»è‡³åç«¯ï¼ˆä¾‹å¦‚ Next.js API è·¯ç”±ï¼‰
  const FIRECRAWL_API_URL = "https://api.firecrawl.dev"; // å°†å…¶æ›¿æ¢ä¸ºä½ çš„å®é™… API URLï¼ˆæœ¬åœ°æˆ– Firecrawl Cloud å‡å¯ï¼‰
  const FIRECRAWL_API_KEY = "fc-YOUR_API_KEY"; // å°†å…¶æ›¿æ¢ä¸ºä½ çš„å®é™… API Key

  interface FormData {
    url: string;
    crawlSubPages: boolean;
    limit: string;
    maxDepth: string;
    excludePaths: string;
    includePaths: string;
    extractMainContent: boolean;
  }

  interface CrawlerOptions {
    includes?: string[];
    excludes?: string[];
    maxDepth?: number;
    limit?: number;
    returnOnlyUrls: boolean;
  }

  interface PageOptions {
    onlyMainContent: boolean;
  }

  interface RequestBody {
    url: string;
    crawlerOptions?: CrawlerOptions;
    pageOptions: PageOptions;
  }

  interface ScrapeResultMetadata {
    title: string;
    description: string;
    language: string;
    sourceURL: string;
    pageStatusCode: number;
    pageError?: string;
    [key: string]: string | number | undefined;
  }

  interface ScrapeResultData {
    markdown: string;
    content: string;
    html: string;
    rawHtml: string;
    metadata: ScrapeResultMetadata;
    llm_extraction: Record<string, unknown>;
    warning?: string;
  }

  interface ScrapeResult {
    success: boolean;
    data: ScrapeResultData;
  }

  export default function FirecrawlComponent() {
    const [formData, setFormData] = useState<FormData>({
      url: "",
      crawlSubPages: false,
      limit: "",
      maxDepth: "",
      excludePaths: "",
      includePaths: "",
      extractMainContent: false,
    });
    const [loading, setLoading] = useState<boolean>(false);
    const [scrapingSelectedLoading, setScrapingSelectedLoading] =
      useState<boolean>(false);
    const [crawledUrls, setCrawledUrls] = useState<string[]>([]);
    const [selectedUrls, setSelectedUrls] = useState<string[]>([]);
    const [scrapeResults, setScrapeResults] = useState<
      Record<string, ScrapeResult>
    >({});
    const [isCollapsibleOpen, setIsCollapsibleOpen] = useState(true);
    const [crawlStatus, setCrawlStatus] = useState<{
      current: number;
      total: number | null;
    }>({ current: 0, total: null });
    const [elapsedTime, setElapsedTime] = useState<number>(0);
    const [showCrawlStatus, setShowCrawlStatus] = useState<boolean>(false);
    const [isScraping, setIsScraping] = useState<boolean>(false);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const urlsPerPage = 10;

    useEffect(() => {
      let timer: NodeJS.Timeout;
      if (loading) {
        setShowCrawlStatus(true);
        timer = setInterval(() => {
          setElapsedTime((prevTime) => prevTime + 1);
        }, 1000);
      }
      return () => {
        if (timer) clearInterval(timer);
      };
    }, [loading]);

    const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
      const { name, value, type, checked } = e.target;
      setFormData((prevData) => ({
        ...prevData,
        [name]: type === "checkbox" ? checked : value,
      }));
    };

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setLoading(true);
      setIsCollapsibleOpen(false);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: null });
      setIsScraping(!formData.crawlSubPages);
      setCrawledUrls([]);
      setSelectedUrls([]);
      setScrapeResults({});
      setScrapingSelectedLoading(false);
      setShowCrawlStatus(false);

      try {
        const endpoint = `${FIRECRAWL_API_URL}/v0/${
          formData.crawlSubPages ? "crawl" : "scrape"
        }`;

        const requestBody: RequestBody = formData.crawlSubPages
          ? {
              url: formData.url,
              crawlerOptions: {
                includes: formData.includePaths
                  ? formData.includePaths.split(",").map((p) => p.trim())
                  : undefined,
                excludes: formData.excludePaths
                  ? formData.excludePaths.split(",").map((p) => p.trim())
                  : undefined,
                maxDepth: formData.maxDepth
                  ? parseInt(formData.maxDepth)
                  : undefined,
                limit: formData.limit ? parseInt(formData.limit) : undefined,
                returnOnlyUrls: true,
              },
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }
          : {
              url: formData.url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            };

        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          throw new Error(`HTTP é”™è¯¯ï¼çŠ¶æ€ç : ${response.status}`);
        }

        const data = await response.json();
        if (formData.crawlSubPages) {
          const jobId = data.jobId;
          if (jobId) {
            const statusEndpoint = `${FIRECRAWL_API_URL}/v0/crawl/status/${jobId}`;
            let statusData: {
              status: string;
              data?: { url: string }[];
              current?: number;
              total?: number;
            };
            do {
              const statusResponse = await fetch(statusEndpoint, {
                headers: {
                  Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
                },
              });
              if (statusResponse.ok) {
                statusData = await statusResponse.json();

                const urls = statusData.data
                  ? statusData.data.map((urlObj) => urlObj.url)
                  : [];
                setCrawledUrls(urls);
                setSelectedUrls(urls);
                setCrawlStatus({
                  current: urls.length || 0,
                  total: urls.length || null,
                });
                if (statusData.status !== "completed") {
                  // å†ç­‰å¾… 1 ç§’åç»§ç»­è½®è¯¢
                  await new Promise((resolve) => setTimeout(resolve, 1000));
                  console.log("å†æ¬¡è½®è¯¢ä¸­...");
                  console.log(statusData);
                } else {
                  console.log("çˆ¬å–å®Œæˆï¼ŒçŠ¶æ€ï¼š", statusData.status);
                  console.log(statusData);
                }
              } else {
                console.error("è·å–çˆ¬å–çŠ¶æ€å¤±è´¥");
                break;
              }
            } while (statusData.status !== "completed");
          } else {
            console.error("çˆ¬å–è¯·æ±‚æœªè¿”å› jobId");
          }
        } else {
          setScrapeResults({ [formData.url]: data });
          setCrawlStatus({ current: 1, total: 1 });
        }
      } catch (error) {
        console.error("é”™è¯¯ï¼š", error);
        setScrapeResults({
          error: {
            success: false,
            data: {
              metadata: {
                pageError: "è·å–æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯",
                title: "",
                description: "",
                language: "",
                sourceURL: "",
                pageStatusCode: 0,
              },
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              llm_extraction: {},
            },
          },
        });
      } finally {
        setLoading(false);
      }
    };

    const handleScrapeSelected = async () => {
      setLoading(true);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: selectedUrls.length });
      setIsScraping(true);
      setScrapingSelectedLoading(true);
      const newScrapeResults: Record<string, ScrapeResult> = {};

      for (const [index, url] of selectedUrls.entries()) {
        try {
          const response = await fetch(`${FIRECRAWL_API_URL}/v0/scrape`, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              url: url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP é”™è¯¯ï¼çŠ¶æ€ç : ${response.status}`);
          }

          const data: ScrapeResult = await response.json();
          newScrapeResults[url] = data;
          setCrawlStatus((prev) => ({ ...prev, current: index + 1 }));
          setScrapeResults({ ...scrapeResults, ...newScrapeResults });
        } catch (error) {
          console.error(`æŠ“å– ${url} æ—¶å‡ºé”™ï¼š`, error);
          newScrapeResults[url] = {
            success: false,
            data: {
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              metadata: {
                title: "",
                description: "",
                language: "",
                sourceURL: url,
                pageStatusCode: 0,
                pageError: (error as Error).message,
              },
              llm_extraction: {},
            },
          };
        }
      }

      setLoading(false);
      setIsScraping(false);
    };

    const handlePageChange = (newPage: number) => {
      setCurrentPage(newPage);
    };

    const paginatedUrls = crawledUrls.slice(
      (currentPage - 1) * urlsPerPage,
      currentPage * urlsPerPage
    );

    return (
      <div className="max-w-2xl mx-auto p-4">
        <Card>
          <CardHeader className="flex items-start justify-between mb-0 pb-4">
            <CardTitle className="flex items-center justify-between w-full space-x-2">
              <span className="text-base">æå–ç½‘é¡µå†…å®¹</span>
              <a
                href="https://www.firecrawl.dev"
                className="text-xs text-gray-500 font-normal px-3 py-1 bg-zinc-100 rounded-xl hover:bg-zinc-200 transition-colors"
              >
                Powered by Firecrawl ğŸ”¥
              </a>
            </CardTitle>
            <div className="text-sm text-gray-500 w-11/12 items-center">
              ä½¿ç”¨è¯¥ç»„ä»¶å¯è®©ä½ çš„ç”¨æˆ·å¿«é€Ÿå°†å…¶ AI åº”ç”¨è¿æ¥åˆ°ç½‘é¡µæ•°æ®ï¼ˆé€šè¿‡ Firecrawlï¼‰ã€‚äº†è§£æ›´å¤šè¯·æŸ¥çœ‹{" "}
              their AI apps to web data with Firecrawl. Learn more on the{" "}
              <a
                href="https://docs.firecrawl.dev/"
                className="text-sm text-blue-500"
              >
                Firecrawl æ–‡æ¡£ï¼
              </a>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <form onSubmit={handleSubmit}>
              <div className="flex items-center space-x-2">
                <Input
                  placeholder="https://www.firecrawl.dev/"
                  className="flex-grow"
                  name="url"
                  value={formData.url}
                  onChange={handleChange}
                />
                <Button type="submit" variant="default" disabled={loading}>
                  {loading ? (
                    <div
                      role="status"
                      className="flex items-center justify-between space-x-2"
                    >
                      <svg
                        className="animate-spin  h-4 w-4 text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                        ></circle>
                        <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                      <span className="sr-only">åŠ è½½ä¸­...</span>
                    </div>
                  ) : (
                    "è¿è¡Œ"
                  )}
                </Button>
              </div>
              <Collapsible
                open={isCollapsibleOpen}
                onOpenChange={setIsCollapsibleOpen}
                className="mt-2"
              >
                <CollapsibleTrigger asChild>
                  <Button variant="ghost" className="w-full justify-between pl-2">
                    é«˜çº§é€‰é¡¹
                    <ChevronDown className="h-4 w-4 opacity-50" />
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="space-y-4 mt-4 px-2">
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="crawlSubPages"
                      name="crawlSubPages"
                      checked={formData.crawlSubPages}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          crawlSubPages: checked,
                        }))
                      }
                    />
                    <label htmlFor="crawlSubPages" className="text-sm">
                      çˆ¬å–å­é¡µé¢
                    </label>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="limit"
                        className="block text-left w-full pb-2"
                      >
                        æ•°é‡ä¸Šé™ *
                      </Label>
                      <Input
                        id="limit"
                        name="limit"
                        placeholder="10"
                        value={formData.limit}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="maxDepth"
                        className="block text-left w-full pb-2"
                      >
                        æœ€å¤§æ·±åº¦
                      </Label>
                      <Input
                        id="maxDepth"
                        name="maxDepth"
                        placeholder="5"
                        value={formData.maxDepth}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="excludePaths"
                        className="block text-left w-full pb-2"
                      >
                        æ’é™¤è·¯å¾„
                      </Label>
                      <Input
                        id="excludePaths"
                        name="excludePaths"
                        placeholder="blog/, /about/"
                        value={formData.excludePaths}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="includePaths"
                        className="block text-left w-full pb-2"
                      >
                        ä»…åŒ…å«è¿™äº›è·¯å¾„
                      </Label>
                      <Input
                        id="includePaths"
                        name="includePaths"
                        placeholder="articles/"
                        value={formData.includePaths}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="extractMainContent"
                      name="extractMainContent"
                      checked={formData.extractMainContent}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          extractMainContent: checked,
                        }))
                      }
                    />
                    <label htmlFor="extractMainContent" className="text-sm">
                      ä»…æå–ä¸»ä½“å†…å®¹ï¼ˆä¸å«é¡µçœ‰ã€å¯¼èˆªã€é¡µè„šç­‰ï¼‰
                    </label>
                  </div>
                </CollapsibleContent>
              </Collapsible>
            </form>
            {showCrawlStatus && (
              <div className="flex items-center justify-between mb-2 space-x-2 bg-gray-100 p-2 rounded-md">
                <div className="flex items-center space-x-2">
                  {!isScraping &&
                    crawledUrls.length > 0 &&
                    !scrapingSelectedLoading && (
                      <>
                        <Checkbox
                          id="selectAll"
                          checked={selectedUrls.length === crawledUrls.length}
                          onCheckedChange={(checked) => {
                            if (checked) {
                              setSelectedUrls([...crawledUrls]);
                            } else {
                              setSelectedUrls([]);
                            }
                          }}
                        />
                        <label
                          htmlFor="selectAll"
                          className="text-sm cursor-pointer"
                        >
                          {selectedUrls.length === crawledUrls.length
                            ? `å–æ¶ˆå…¨é€‰ï¼ˆ${selectedUrls.length}ï¼‰`
                            : `å…¨é€‰ï¼ˆ${selectedUrls.length}ï¼‰`}
                        </label>
                      </>
                    )}
                </div>
                <div className="text-sm text-gray-600">
                  {isScraping
                    ? `å·²æŠ“å– ${crawlStatus.current} ä¸ªé¡µé¢ï¼Œç”¨æ—¶ ${elapsedTime}s`
                    : `å·²çˆ¬å– ${crawlStatus.current} ä¸ªé¡µé¢ï¼Œç”¨æ—¶ ${elapsedTime}s`}
                </div>
              </div>
            )}

            {crawledUrls.length > 0 &&
              !scrapingSelectedLoading &&
              !isScraping && (
                <>
                  <ul className="pl-2">
                    {paginatedUrls.map((url, index) => (
                      <li
                        key={index}
                        className="flex items-center space-x-2 my-2 text-sm"
                      >
                        <Checkbox
                          checked={selectedUrls.includes(url)}
                          onCheckedChange={() =>
                            setSelectedUrls((prev) =>
                              prev.includes(url)
                                ? prev.filter((u) => u !== url)
                                : [...prev, url]
                            )
                          }
                        />
                        <span className="flex items-center max-w-lg">
                          {url.length > 70 ? `${url.slice(0, 70)}...` : url}
                        </span>
                      </li>
                    ))}
                  </ul>
                  <div className="flex items-center justify-between mt-4">
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage - 1)}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-5 w-5" />
                    </Button>
                    <span className="text-sm text-gray-500">
                      ç¬¬ {currentPage} é¡µï¼Œå…±{" "}
                      {Math.ceil(crawledUrls.length / urlsPerPage)}
                    </span>
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage + 1)}
                      disabled={currentPage * urlsPerPage >= crawledUrls.length}
                    >
                      <ChevronRight className="h-5 w-5 " />
                    </Button>
                  </div>
                </>
              )}
          </CardContent>
          <CardFooter className="w-full flex justify-center">
            {crawledUrls.length > 0 && !scrapingSelectedLoading && (
              <Button
                variant="default"
                className="w-full"
                onClick={handleScrapeSelected}
                disabled={loading || selectedUrls.length === 0}
              >
                æŠ“å–æ‰€é€‰ URL
              </Button>
            )}
          </CardFooter>
        </Card>

        {Object.keys(scrapeResults).length > 0 && (
          <div className="mt-4">
            <h2 className="text-base font-bold ">æŠ“å–ç»“æœ</h2>
            <p className="text-sm text-gray-500">
              ä½ å¯ä»¥æŒ‰éœ€å¤„ç†æŠ“å–ç»“æœã€‚ä¸‹é¢æ˜¯ä¸€ä¸ª
              åŸºç¡€çš„ Markdown ç¤ºä¾‹ã€‚
            </p>
            <div className="flex flex-col gap-4 mt-4 w-full">
              {Object.entries(scrapeResults).map(([url, result]) => (
                <Card key={url} className="relative p-4 w-full">
                  <CardTitle className="text-sm font-normal flex flex-col">
                    <span>{result.data.metadata.title}</span>
                    <span className="text-xs text-gray-500">
                      {url
                        .replace(/^(https?:\/\/)?(www\.)?/, "")
                        .replace(/\/$/, "")}
                    </span>
                  </CardTitle>
                  <CardContent className="relative px-0 pt-2 !text-xs w-full">
                    <div className=" overflow-y-auto h-32 bg-zinc-100 rounded-md p-2 w-full">
                      {result.success ? (
                        <>
                          <pre className="text-xs whitespace-pre-wrap">
                            {result.data.markdown.trim()}
                          </pre>
                        </>
                      ) : (
                        <>
                          <p className="text-red-500">
                            æŠ“å–è¯¥ URL å¤±è´¥
                          </p>
                          <p className="text-zinc-500 font-mono">
                            {result.toString()}
                          </p>
                        </>
                      )}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }
  ```
</Accordion>

<div id="customization">
  ## è‡ªå®šä¹‰
</div>

ç”±äºè¿™ä¸æ˜¯ä¸€ä¸ªåº“ï¼Œä½ å¯ä»¥æŒ‰éœ€è‡ªå®šä¹‰ UIã€‚åƒä½¿ç”¨ shadcn ä¸€æ ·ï¼Œç›´æ¥ä¿®æ”¹ä»£ç å³å¯ã€‚

<div id="security-considerations">
  ## å®‰å…¨æ³¨æ„äº‹é¡¹
</div>

åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¯·è€ƒè™‘ä»¥ä¸‹å®‰å…¨æªæ–½ï¼š

* å°† API äº¤äº’æ”¾åˆ°æœåŠ¡ç«¯å®ç°ï¼Œä»¥ä¿æŠ¤ä½ çš„ Firecrawl API å¯†é’¥ã€‚

<div id="learn-more">
  ## äº†è§£æ›´å¤š
</div>

å¦‚éœ€è¿›ä¸€æ­¥äº†è§£ Firecrawl åŠå…¶ APIï¼Œè¯·è®¿é—® [Firecrawl æ–‡æ¡£](https://docs.firecrawl.dev/)ã€‚

<div id="contributing">
  ## è´¡çŒ®
</div>

æ¬¢è¿å‚ä¸è´¡çŒ®ï¼æ¬¢è¿éšæ—¶æäº¤ Pull Requestã€‚

<div id="license">
  ## è®¸å¯
</div>

Firecrawl Ingestion UI æ¨¡æ¿é‡‡ç”¨ MIT è®¸å¯è¯æˆæƒã€‚