---
title: 'Go'
description: 'Firecrawl Go SDK 是对 Firecrawl API 的封装，助你轻松将网站内容转换为 Markdown。'
icon: 'golang'
og:title: "Go SDK | Firecrawl"
og:description: "Firecrawl Go SDK 是对 Firecrawl API 的封装，助你轻松将网站内容转换为 Markdown。"
---

> 注意：此处使用的是即将弃用的 [Firecrawl API v0 版本](/zh/v0/introduction)。建议切换到 [v1](/zh/sdks/go)。

<div id="installation">
  ## 安装
</div>

要安装 Firecrawl 的 Go SDK，可使用 go get：

```bash
go get github.com/mendableai/firecrawl-go
```

<div id="usage">
  ## 用法
</div>

1. 从 [firecrawl.dev](https://firecrawl.dev) 获取 API 密钥
2. 将该密钥设置为名为 `FIRECRAWL_API_KEY` 的环境变量，或作为参数传递给 `FirecrawlApp` 结构体。

下面是一个包含错误处理的 SDK 使用示例：

```go
import (
  "fmt"
  "log"

  "github.com/mendableai/firecrawl-go"
)

func main() {
  // 使用你的 API Key 初始化 FirecrawlApp
  app, err := firecrawl.NewFirecrawlApp("YOUR_API_KEY")
  if err != nil {
    log.Fatalf("FirecrawlApp 初始化失败：%v", err)
  }

  // 抓取单个 URL
  scrapedData, err := app.ScrapeURL("docs.firecrawl.dev", nil)
  if err != nil {
    log.Fatalf("抓取时出错：%v", err)
  }
  fmt.Println(scrapedData)

  // 爬取站点
  params := map[string]any{
    "pageOptions": map[string]any{
      "onlyMainContent": true,
    },
  }

  crawlResult, err := app.CrawlURL("docs.firecrawl.dev", params)
  if err != nil {
    log.Fatalf("爬取时出错：%v", err)
  }
  fmt.Println(crawlResult)
}
```

<div id="scraping-a-url">
  ### 抓取 URL
</div>

要抓取单个 URL 并处理错误，请使用 `ScrapeURL` 方法。该方法接受 URL 作为参数，返回包含抓取数据的字典。

```go
scrapedData, err := app.ScrapeURL("docs.firecrawl.dev", nil)
if err != nil {
  log.Fatalf("抓取 URL 失败：%v", err)
}
fmt.Println(scrapedData)
```

<div id="crawling-a-website">
  ### 抓取网站
</div>

要抓取网站，请使用 `CrawlUrl` 方法。它接受起始 URL 和可选参数。通过 `params` 参数，你可以为抓取任务指定其他选项，例如最大抓取页数、允许的域名以及输出格式。

```go
crawlParams := map[string]any{
  "crawlerOptions": map[string]any{
    "excludes": []string{"blog/*"},
    "includes": []string{}, // 留空以抓取所有页面
    "limit": 1000,
  },
  "pageOptions": map[string]any{
    "onlyMainContent": true,
  },
}
crawlResult, err := app.CrawlURL("docs.firecrawl.dev", crawlParams, true, 2, idempotencyKey)
if err != nil {
  log.Fatalf("爬取 URL 失败：%v", err)
}
fmt.Println(crawlResult)
```

<div id="checking-crawl-status">
  ### 检查爬取状态
</div>

要查看爬取任务的状态，请使用 `CheckCrawlStatus` 方法。该方法接收任务 ID 作为参数，并返回该爬取任务的当前状态。

```go
status, err := app.CheckCrawlStatus(jobId)
if err != nil {
  log.Fatalf("检查爬取状态失败：%v", err)
}
fmt.Println(status)
```

<div id="canceling-a-crawl-job">
  ### 取消爬取任务
</div>

要取消爬取任务，请使用 `CancelCrawlJob` 方法。该方法接受任务 ID 作为参数，并返回该爬取任务的取消状态。

```go
canceled, err := app.CancelCrawlJob(jobId)
if err != nil {
  log.Fatalf("取消爬取任务失败：%v", err)
}
fmt.Println(canceled)
```

<div id="extracting-structured-data-from-a-url">
  ### 从 URL 提取结构化数据
</div>

借助 LLM 提取，你可以轻松从任意 URL 获取结构化数据。以下是使用方法：

```go
jsonSchema := map[string]any{
  "type": "object",
  "properties": map[string]any{
    "top": map[string]any{
      "type": "array",
      "items": map[string]any{
        "type": "object",
        "properties": map[string]any{
          "title":       map[string]string{"type": "string"},
          "points":      map[string]string{"type": "number"},
          "by":          map[string]string{"type": "string"},
          "commentsURL": map[string]string{"type": "string"},
        },
        "required": []string{"title", "points", "by", "commentsURL"},
      },
      "minItems":    5,
      "maxItems":    5,
      "description": "Hacker News 上的前 5 篇文章",
    },
  },
  "required": []string{"top"},
}

llmExtractionParams := map[string]any{
  "extractorOptions": firecrawl.ExtractorOptions{
    ExtractionSchema: jsonSchema,
  },
}

scrapeResult, err := app.ScrapeURL("https://news.ycombinator.com", llmExtractionParams)
if err != nil {
  log.Fatalf("LLM 提取失败：%v", err)
}
fmt.Println(scrapeResult)
```

<div id="search-for-a-query">
  ### 搜索查询
</div>

要在网上搜索、获取最相关的结果、抓取每个页面并以 markdown 返回内容，请使用 `Search` 方法。该方法接收查询作为参数并返回搜索结果。

```go
query := "什么是 Firecrawl？"
searchResult, err := app.Search(query)
if err != nil {
  log.Fatalf("搜索失败：%v", err)
}
fmt.Println(searchResult)
```

<div id="error-handling">
  ## 错误处理
</div>

SDK 会处理 Firecrawl API 返回的错误并抛出相应的异常。如果在请求过程中发生错误，将抛出包含详细错误信息的异常。