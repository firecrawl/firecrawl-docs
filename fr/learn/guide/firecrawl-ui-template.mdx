---
title: "Mod√®le d‚Äôinterface Web Connector"
description: "Guide de configuration d‚Äôune interface d‚Äôingestion web avec Firecrawl et React."
og:title: "Mod√®le d‚Äôinterface Web Connector | Firecrawl"
og:description: "Apprenez √† configurer une interface d‚Äôingestion web avec Firecrawl et React."
---

> Remarque : cet exemple utilise la [version v0 de l‚ÄôAPI Firecrawl](/fr/v0/introduction). Vous pouvez installer la version 0.0.20 pour le SDK Python ou la 0.0.36 pour le SDK Node.

Ce mod√®le facilite la cr√©ation d‚Äôune interface de connecteur web pour Firecrawl avec React.
Il inclut un composant pr√™t √† l‚Äôemploi qui interagit avec l‚ÄôAPI Firecrawl, vous permettant de mettre rapidement en place une interface d‚Äôexploration et de scraping web pour permettre aux utilisateurs d‚Äôextraire des donn√©es pour leurs applications d‚ÄôIA.
![Firecrawl UI Template](/images/firecrawl-ui.png)

Ce mod√®le permet aux utilisateurs de saisir une URL √† explorer. Si des sous-pages sont d√©tect√©es, le mod√®le les explorera et affichera une liste des URL d√©couvertes. Les utilisateurs peuvent ensuite s√©lectionner les URL √† scraper, et le contenu extrait sera ing√©r√© dans leur application d‚ÄôIA et affich√© dans l‚Äôinterface.

> **Consid√©rations de s√©curit√© : cet exemple expose des cl√©s d‚ÄôAPI Firecrawl dans le code c√¥t√© client. Pour un usage en production, il est fortement recommand√© de d√©placer les interactions avec l‚ÄôAPI vers une impl√©mentation c√¥t√© serveur afin de prot√©ger vos cl√©s d‚ÄôAPI.**

<div id="prerequisites">
  ## Pr√©requis
</div>

* Node.js (v14 ou ult√©rieure recommand√©)
* npm
* Assurez-vous d‚Äôavoir install√© [shadcn](https://github.com/shadcn-ui/ui)
* Assurez-vous d‚Äôavoir install√© [Tailwind CSS](https://tailwindcss.com/docs/installation)

<div id="getting-started">
  ## Prise en main
</div>

1. Installez les d√©pendances¬†:

* Installez les [composants shadcn](https://github.com/shadcn-ui/ui) dont vous avez besoin¬†:

```
npx shadcn-ui@latest add button card checkbox collapsible input label
```

* Installez le reste des d√©pendances :

```
npm install clsx lucide-react tailwind-merge tailwindcss-animate class-variance-authority
```

2. Cr√©ez un fichier `lib/utils.ts`, puis ajoutez le code suivant¬†:

```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

3. Copiez et collez notre composant principal d‚Äôingestion. **Assurez-vous de remplacer `FIRECRAWL_API_KEY` par votre propre cl√©.**

<Accordion title="Composant d‚Äôingestion (ingestion.tsx)">
  ```jsx
  import { useState, ChangeEvent, FormEvent, useEffect } from "react";
  import {
    Card,
    CardHeader,
    CardTitle,
    CardContent,
    CardFooter,
  } from "@/components/ui/card";
  import { Input } from "@/components/ui/input";
  import { Button } from "@/components/ui/button";
  import { Checkbox } from "@/components/ui/checkbox";
  import { Label } from "@/components/ui/label";
  import {
    Collapsible,
    CollapsibleContent,
    CollapsibleTrigger,
  } from "@/components/ui/collapsible";
  import { ChevronDown, ChevronLeft, ChevronRight } from "lucide-react";

  //! Valeurs en dur (d√©conseill√©es en production)
  //! Il est vivement recommand√© de d√©placer tous les appels √† l‚ÄôAPI Firecrawl vers le backend (p. ex. une route API Next.js)
  const FIRECRAWL_API_URL = "https://api.firecrawl.dev"; // Remplacez par l‚ÄôURL r√©elle de votre API, en local ou via Firecrawl Cloud
  const FIRECRAWL_API_KEY = "fc-YOUR_API_KEY"; // Remplacez par votre cl√© d‚ÄôAPI r√©elle

  interface FormData {
    url: string;
    crawlSubPages: boolean;
    limit: string;
    maxDepth: string;
    excludePaths: string;
    includePaths: string;
    extractMainContent: boolean;
  }

  interface CrawlerOptions {
    includes?: string[];
    excludes?: string[];
    maxDepth?: number;
    limit?: number;
    returnOnlyUrls: boolean;
  }

  interface PageOptions {
    onlyMainContent: boolean;
  }

  interface RequestBody {
    url: string;
    crawlerOptions?: CrawlerOptions;
    pageOptions: PageOptions;
  }

  interface ScrapeResultMetadata {
    title: string;
    description: string;
    language: string;
    sourceURL: string;
    pageStatusCode: number;
    pageError?: string;
    [key: string]: string | number | undefined;
  }

  interface ScrapeResultData {
    markdown: string;
    content: string;
    html: string;
    rawHtml: string;
    metadata: ScrapeResultMetadata;
    llm_extraction: Record<string, unknown>;
    warning?: string;
  }

  interface ScrapeResult {
    success: boolean;
    data: ScrapeResultData;
  }

  export default function FirecrawlComponent() {
    const [formData, setFormData] = useState<FormData>({
      url: "",
      crawlSubPages: false,
      limit: "",
      maxDepth: "",
      excludePaths: "",
      includePaths: "",
      extractMainContent: false,
    });
    const [loading, setLoading] = useState<boolean>(false);
    const [scrapingSelectedLoading, setScrapingSelectedLoading] =
      useState<boolean>(false);
    const [crawledUrls, setCrawledUrls] = useState<string[]>([]);
    const [selectedUrls, setSelectedUrls] = useState<string[]>([]);
    const [scrapeResults, setScrapeResults] = useState<
      Record<string, ScrapeResult>
    >({});
    const [isCollapsibleOpen, setIsCollapsibleOpen] = useState(true);
    const [crawlStatus, setCrawlStatus] = useState<{
      current: number;
      total: number | null;
    }>({ current: 0, total: null });
    const [elapsedTime, setElapsedTime] = useState<number>(0);
    const [showCrawlStatus, setShowCrawlStatus] = useState<boolean>(false);
    const [isScraping, setIsScraping] = useState<boolean>(false);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const urlsPerPage = 10;

    useEffect(() => {
      let timer: NodeJS.Timeout;
      if (loading) {
        setShowCrawlStatus(true);
        timer = setInterval(() => {
          setElapsedTime((prevTime) => prevTime + 1);
        }, 1000);
      }
      return () => {
        if (timer) clearInterval(timer);
      };
    }, [loading]);

    const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
      const { name, value, type, checked } = e.target;
      setFormData((prevData) => ({
        ...prevData,
        [name]: type === "checkbox" ? checked : value,
      }));
    };

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setLoading(true);
      setIsCollapsibleOpen(false);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: null });
      setIsScraping(!formData.crawlSubPages);
      setCrawledUrls([]);
      setSelectedUrls([]);
      setScrapeResults({});
      setScrapingSelectedLoading(false);
      setShowCrawlStatus(false);

      try {
        const endpoint = `${FIRECRAWL_API_URL}/v0/${
          formData.crawlSubPages ? "crawl" : "scrape"
        }`;

        const requestBody: RequestBody = formData.crawlSubPages
          ? {
              url: formData.url,
              crawlerOptions: {
                includes: formData.includePaths
                  ? formData.includePaths.split(",").map((p) => p.trim())
                  : undefined,
                excludes: formData.excludePaths
                  ? formData.excludePaths.split(",").map((p) => p.trim())
                  : undefined,
                maxDepth: formData.maxDepth
                  ? parseInt(formData.maxDepth)
                  : undefined,
                limit: formData.limit ? parseInt(formData.limit) : undefined,
                returnOnlyUrls: true,
              },
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }
          : {
              url: formData.url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            };

        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP¬†! statut¬†: ${response.status}`);
        }

        const data = await response.json();
        if (formData.crawlSubPages) {
          const jobId = data.jobId;
          if (jobId) {
            const statusEndpoint = `${FIRECRAWL_API_URL}/v0/crawl/status/${jobId}`;
            let statusData: {
              status: string;
              data?: { url: string }[];
              current?: number;
              total?: number;
            };
            do {
              const statusResponse = await fetch(statusEndpoint, {
                headers: {
                  Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
                },
              });
              if (statusResponse.ok) {
                statusData = await statusResponse.json();

                const urls = statusData.data
                  ? statusData.data.map((urlObj) => urlObj.url)
                  : [];
                setCrawledUrls(urls);
                setSelectedUrls(urls);
                setCrawlStatus({
                  current: urls.length || 0,
                  total: urls.length || null,
                });
                if (statusData.status !== "completed") {
                  // Attendre 1 seconde avant un nouveau poll
                  await new Promise((resolve) => setTimeout(resolve, 1000));
                  console.log("Nouveau sondage‚Ä¶");
                  console.log(statusData);
                } else {
                  console.log("Exploration termin√©e avec le statut¬†:", statusData.status);
                  console.log(statusData);
                }
              } else {
                console.error("√âchec de la r√©cup√©ration du statut d‚Äôexploration");
                break;
              }
            } while (statusData.status !== "completed");
          } else {
            console.error("Aucun jobId re√ßu depuis la requ√™te d‚Äôexploration");
          }
        } else {
          setScrapeResults({ [formData.url]: data });
          setCrawlStatus({ current: 1, total: 1 });
        }
      } catch (error) {
        console.error("Erreur¬†:", error);
        setScrapeResults({
          error: {
            success: false,
            data: {
              metadata: {
                pageError: "Une erreur est survenue lors de la r√©cup√©ration des donn√©es",
                title: "",
                description: "",
                language: "",
                sourceURL: "",
                pageStatusCode: 0,
              },
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              llm_extraction: {},
            },
          },
        });
      } finally {
        setLoading(false);
      }
    };

    const handleScrapeSelected = async () => {
      setLoading(true);
      setElapsedTime(0);
      setCrawlStatus({ current: 0, total: selectedUrls.length });
      setIsScraping(true);
      setScrapingSelectedLoading(true);
      const newScrapeResults: Record<string, ScrapeResult> = {};

      for (const [index, url] of selectedUrls.entries()) {
        try {
          const response = await fetch(`${FIRECRAWL_API_URL}/v0/scrape`, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${FIRECRAWL_API_KEY}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              url: url,
              pageOptions: {
                onlyMainContent: formData.extractMainContent,
              },
            }),
          });

          if (!response.ok) {
            throw new Error(`Erreur HTTP¬†! statut¬†: ${response.status}`);
          }

          const data: ScrapeResult = await response.json();
          newScrapeResults[url] = data;
          setCrawlStatus((prev) => ({ ...prev, current: index + 1 }));
          setScrapeResults({ ...scrapeResults, ...newScrapeResults });
        } catch (error) {
          console.error(`Erreur lors de l‚Äôextraction de ${url}¬†:`, error);
          newScrapeResults[url] = {
            success: false,
            data: {
              markdown: "",
              content: "",
              html: "",
              rawHtml: "",
              metadata: {
                title: "",
                description: "",
                language: "",
                sourceURL: url,
                pageStatusCode: 0,
                pageError: (error as Error).message,
              },
              llm_extraction: {},
            },
          };
        }
      }

      setLoading(false);
      setIsScraping(false);
    };

    const handlePageChange = (newPage: number) => {
      setCurrentPage(newPage);
    };

    const paginatedUrls = crawledUrls.slice(
      (currentPage - 1) * urlsPerPage,
      currentPage * urlsPerPage
    );

    return (
      <div className="max-w-2xl mx-auto p-4">
        <Card>
          <CardHeader className="flex items-start justify-between mb-0 pb-4">
            <CardTitle className="flex items-center justify-between w-full space-x-2">
              <span className="text-base">Extraire du contenu web</span>
              <a
                href="https://www.firecrawl.dev"
                className="text-xs text-gray-500 font-normal px-3 py-1 bg-zinc-100 rounded-xl hover:bg-zinc-200 transition-colors"
              >
                Propuls√© par Firecrawl üî•
              </a>
            </CardTitle>
            <div className="text-sm text-gray-500 w-11/12 items-center">
              Utilisez ce composant pour offrir rapidement √† vos utilisateurs la possibilit√© de connecter
              leurs applications d‚ÄôIA aux donn√©es web avec Firecrawl. En savoir plus dans la{" "}
              <a
                href="https://docs.firecrawl.dev/"
                className="text-sm text-blue-500"
              >
                documentation Firecrawl¬†!
              </a>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <form onSubmit={handleSubmit}>
              <div className="flex items-center space-x-2">
                <Input
                  placeholder="https://www.firecrawl.dev/"
                  className="flex-grow"
                  name="url"
                  value={formData.url}
                  onChange={handleChange}
                />
                <Button type="submit" variant="default" disabled={loading}>
                  {loading ? (
                    <div
                      role="status"
                      className="flex items-center justify-between space-x-2"
                    >
                      <svg
                        className="animate-spin  h-4 w-4 text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                        ></circle>
                        <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                      <span className="sr-only">Chargement‚Ä¶</span>
                    </div>
                  ) : (
                    "Ex√©cuter"
                  )}
                </Button>
              </div>
              <Collapsible
                open={isCollapsibleOpen}
                onOpenChange={setIsCollapsibleOpen}
                className="mt-2"
              >
                <CollapsibleTrigger asChild>
                  <Button variant="ghost" className="w-full justify-between pl-2">
                    Options avanc√©es
                    <ChevronDown className="h-4 w-4 opacity-50" />
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="space-y-4 mt-4 px-2">
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="crawlSubPages"
                      name="crawlSubPages"
                      checked={formData.crawlSubPages}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          crawlSubPages: checked,
                        }))
                      }
                    />
                    <label htmlFor="crawlSubPages" className="text-sm">
                      Explorer les sous-pages
                    </label>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="limit"
                        className="block text-left w-full pb-2"
                      >
                        Limite¬†*
                      </Label>
                      <Input
                        id="limit"
                        name="limit"
                        placeholder="10"
                        value={formData.limit}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="maxDepth"
                        className="block text-left w-full pb-2"
                      >
                        Profondeur max.
                      </Label>
                      <Input
                        id="maxDepth"
                        name="maxDepth"
                        placeholder="5"
                        value={formData.maxDepth}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <Label
                        htmlFor="excludePaths"
                        className="block text-left w-full pb-2"
                      >
                        Exclude paths
                      </Label>
                      <Input
                        id="excludePaths"
                        name="excludePaths"
                        placeholder="blog/, /about/"
                        value={formData.excludePaths}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <Label
                        htmlFor="includePaths"
                        className="block text-left w-full pb-2"
                      >
                        N‚Äôinclure que ces chemins
                      </Label>
                      <Input
                        id="includePaths"
                        name="includePaths"
                        placeholder="articles/"
                        value={formData.includePaths}
                        onChange={handleChange}
                      />
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      id="extractMainContent"
                      name="extractMainContent"
                      checked={formData.extractMainContent}
                      onCheckedChange={(checked: boolean) =>
                        setFormData((prev) => ({
                          ...prev,
                          extractMainContent: checked,
                        }))
                      }
                    />
                    <label htmlFor="extractMainContent" className="text-sm">
                      Extraire uniquement le contenu principal (sans en-t√™tes, navigations, pieds de page, etc.)
                    </label>
                  </div>
                </CollapsibleContent>
              </Collapsible>
            </form>
            {showCrawlStatus && (
              <div className="flex items-center justify-between mb-2 space-x-2 bg-gray-100 p-2 rounded-md">
                <div className="flex items-center space-x-2">
                  {!isScraping &&
                    crawledUrls.length > 0 &&
                    !scrapingSelectedLoading && (
                      <>
                        <Checkbox
                          id="selectAll"
                          checked={selectedUrls.length === crawledUrls.length}
                          onCheckedChange={(checked) => {
                            if (checked) {
                              setSelectedUrls([...crawledUrls]);
                            } else {
                              setSelectedUrls([]);
                            }
                          }}
                        />
                        <label
                          htmlFor="selectAll"
                          className="text-sm cursor-pointer"
                        >
                          {selectedUrls.length === crawledUrls.length
                            ? `Tout d√©s√©lectionner (${selectedUrls.length})`
                            : `Tout s√©lectionner (${selectedUrls.length})`}
                        </label>
                      </>
                    )}
                </div>
                <div className="text-sm text-gray-600">
                  {isScraping
                    ? `Pages extraites¬†: ${crawlStatus.current} en ${elapsedTime}s`
                    : `Pages explor√©es¬†: ${crawlStatus.current} en ${elapsedTime}s`}
                </div>
              </div>
            )}

            {crawledUrls.length > 0 &&
              !scrapingSelectedLoading &&
              !isScraping && (
                <>
                  <ul className="pl-2">
                    {paginatedUrls.map((url, index) => (
                      <li
                        key={index}
                        className="flex items-center space-x-2 my-2 text-sm"
                      >
                        <Checkbox
                          checked={selectedUrls.includes(url)}
                          onCheckedChange={() =>
                            setSelectedUrls((prev) =>
                              prev.includes(url)
                                ? prev.filter((u) => u !== url)
                                : [...prev, url]
                            )
                          }
                        />
                        <span className="flex items-center max-w-lg">
                          {url.length > 70 ? `${url.slice(0, 70)}...` : url}
                        </span>
                      </li>
                    ))}
                  </ul>
                  <div className="flex items-center justify-between mt-4">
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage - 1)}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-5 w-5" />
                    </Button>
                    <span className="text-sm text-gray-500">
                      Page {currentPage} sur{" "}
                      {Math.ceil(crawledUrls.length / urlsPerPage)}
                    </span>
                    <Button
                      variant="outline"
                      className="px-2"
                      onClick={() => handlePageChange(currentPage + 1)}
                      disabled={currentPage * urlsPerPage >= crawledUrls.length}
                    >
                      <ChevronRight className="h-5 w-5 " />
                    </Button>
                  </div>
                </>
              )}
          </CardContent>
          <CardFooter className="w-full flex justify-center">
            {crawledUrls.length > 0 && !scrapingSelectedLoading && (
              <Button
                variant="default"
                className="w-full"
                onClick={handleScrapeSelected}
                disabled={loading || selectedUrls.length === 0}
              >
                Extraire les URL s√©lectionn√©es
              </Button>
            )}
          </CardFooter>
        </Card>

        {Object.keys(scrapeResults).length > 0 && (
          <div className="mt-4">
            <h2 className="text-base font-bold ">R√©sultats de l‚Äôextraction</h2>
            <p className="text-sm text-gray-500">
              Vous pouvez utiliser les r√©sultats comme vous le souhaitez. Voici
              un aper√ßu de base du Markdown.
            </p>
            <div className="flex flex-col gap-4 mt-4 w-full">
              {Object.entries(scrapeResults).map(([url, result]) => (
                <Card key={url} className="relative p-4 w-full">
                  <CardTitle className="text-sm font-normal flex flex-col">
                    <span>{result.data.metadata.title}</span>
                    <span className="text-xs text-gray-500">
                      {url
                        .replace(/^(https?:\/\/)?(www\.)?/, "")
                        .replace(/\/$/, "")}
                    </span>
                  </CardTitle>
                  <CardContent className="relative px-0 pt-2 !text-xs w-full">
                    <div className=" overflow-y-auto h-32 bg-zinc-100 rounded-md p-2 w-full">
                      {result.success ? (
                        <>
                          <pre className="text-xs whitespace-pre-wrap">
                            {result.data.markdown.trim()}
                          </pre>
                        </>
                      ) : (
                        <>
                          <p className="text-red-500">
                            √âchec de l‚Äôextraction de cette URL
                          </p>
                          <p className="text-zinc-500 font-mono">
                            {result.toString()}
                          </p>
                        </>
                      )}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }
  ```
</Accordion>

<div id="customization">
  ## Personnalisation
</div>

Comme ce n‚Äôest pas une biblioth√®que, vous pouvez personnaliser l‚Äôinterface comme vous le souhaitez. Il suffit de modifier le code, √† la mani√®re de shadcn.

<div id="security-considerations">
  ## Consid√©rations de s√©curit√©
</div>

Pour un usage en production, tenez compte des mesures de s√©curit√© suivantes¬†:

* D√©placez les interactions avec l‚ÄôAPI c√¥t√© serveur afin de prot√©ger votre cl√© API Firecrawl.

<div id="learn-more">
  ## En savoir plus
</div>

Pour en savoir plus sur Firecrawl et son API, consultez la [documentation de Firecrawl](https://docs.firecrawl.dev/).

<div id="contributing">
  ## Contribution
</div>

Les contributions sont les bienvenues¬†! N‚Äôh√©sitez pas √† soumettre une pull request.

<div id="license">
  ## Licence
</div>

Le mod√®le d‚Äôinterface d‚Äôingestion Firecrawl est sous licence MIT.